# Stage 3

<3(3/5)!

# Ticket
8e7bd9e37e38a85551d969e29b77e1ce

# Hints

```py
from pwn import *

p = process("./chal4")
# context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']
# 1. In this challenge, you can't open a file because of the strict sandbox
# 2. But there is a vul about the sanbox, it doesn't check the syscall arch.
# 3. We can use x86 syscalls to bypass it. All x86 syscalls: https://syscalls32.paolostivanin.com/
# 4. You may find x86 can't visite x64 address because x64 address is too long to be stored in the x86 register. However, we still have syscall_mmap, which could allocate a chunk of memory, for example 0xcafe000, so we can visite this address in x86 mode. 
# 5. There is a demo for retf: https://github.com/n132/n132.github.io/blob/master/code/GoogleCTF/S2/XxX/pwn.S
context.arch = 'amd64'
shellcode = f'''
mmap a chunk of memory to store the x86 shellcode
and it's also the stack of x86 mode 

read x86 shellcode

retf to x86 mode
'''
gdb.attach(p)
shellcode = asm(shellcode)
p.send(shellcode.ljust(0x100,b'\0'))

context.arch='i386'
context.bits=32

shellcode=f'''
x86 shellcode to cat the flag
'''
p.send(asm(shellcode))
p.interactive()
```
